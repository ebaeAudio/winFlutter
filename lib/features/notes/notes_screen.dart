import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../data/notes/note.dart';
import '../../data/notes/notes_providers.dart';
import '../../ui/app_scaffold.dart';
import '../../ui/components/empty_state_card.dart';
import '../../ui/components/note_card.dart';
import '../../ui/components/note_filters.dart';
import '../../ui/components/note_search_bar.dart';
import '../../ui/spacing.dart';

/// Refresh provider to trigger list updates
final _notesRefreshProvider = StateProvider<int>((_) => 0);

/// Provider that watches the refresh counter
final _notesListWithRefreshProvider =
    FutureProvider.family<List<Note>, NotesFilter>((ref, filter) {
  ref.watch(_notesRefreshProvider);
  return ref.watch(notesListProvider(filter).future);
});

class NotesScreen extends ConsumerStatefulWidget {
  const NotesScreen({super.key});

  @override
  ConsumerState<NotesScreen> createState() => _NotesScreenState();
}

class _NotesScreenState extends ConsumerState<NotesScreen> {
  final _searchController = TextEditingController();
  String _searchQuery = '';
  NoteType? _selectedType;
  bool _showPinned = false;
  bool _showArchived = false;

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _refresh() {
    ref.read(_notesRefreshProvider.notifier).state++;
  }

  void _onSearchChanged(String query) {
    setState(() {
      _searchQuery = query;
    });
  }

  NotesFilter _buildFilter() {
    return NotesFilter(
      type: _selectedType,
      pinned: _showPinned ? true : null,
      archived: _showArchived ? true : null,
    );
  }

  Future<void> _handlePin(Note note) async {
    final repo = ref.read(notesRepositoryProvider);
    if (repo == null) return;

    try {
      await repo.togglePinned(note.id);
      if (!mounted) return;
      _refresh();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(note.pinned ? 'Unpinned' : 'Pinned'),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to update: $e')),
      );
    }
  }

  Future<void> _handleArchive(Note note) async {
    final repo = ref.read(notesRepositoryProvider);
    if (repo == null) return;

    try {
      await repo.archive(note.id);
      if (!mounted) return;
      _refresh();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Archived')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to archive: $e')),
      );
    }
  }

  Future<void> _createNote() async {
    final result = await showDialog<NoteType>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('New Note'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.note_outlined),
              title: const Text('Note'),
              onTap: () => Navigator.of(context).pop(NoteType.note),
            ),
            ListTile(
              leading: const Icon(Icons.inbox_outlined),
              title: const Text('Inbox'),
              onTap: () => Navigator.of(context).pop(NoteType.inbox),
            ),
            ListTile(
              leading: const Icon(Icons.workspaces_outlined),
              title: const Text('Project'),
              onTap: () => Navigator.of(context).pop(NoteType.project),
            ),
          ],
        ),
      ),
    );

    if (result == null || !mounted) return;

    final repo = ref.read(notesRepositoryProvider);
    if (repo == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Notes unavailable. Please configure Supabase.'),
        ),
      );
      return;
    }

    try {
      final note = Note(
        id: '', // Will be generated by database
        userId: '', // Will be set by repository
        title: 'Untitled',
        content: '',
        type: result,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final created = await repo.create(note);
      if (!mounted) return;
      context.go('/settings/notes/${created.id}');
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to create note: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final repo = ref.read(notesRepositoryProvider);
    final filter = _buildFilter();

    // Use search provider if there's a query, otherwise use filtered list
    final asyncNotes = _searchQuery.trim().isNotEmpty
        ? ref.watch(notesSearchProvider(_searchQuery))
        : ref.watch(_notesListWithRefreshProvider(filter));

    return AppScaffold(
      title: 'Notes',
      actions: [
        IconButton(
          tooltip: 'New note',
          onPressed: _createNote,
          icon: const Icon(Icons.note_add_outlined),
        ),
        IconButton(
          tooltip: 'Refresh',
          onPressed: _refresh,
          icon: const Icon(Icons.refresh),
        ),
      ],
      children: [
        NoteSearchBar(
          onSearchChanged: _onSearchChanged,
        ),
        Gap.h16,
        NoteFilters(
          selectedType: _selectedType,
          showPinned: _showPinned,
          showArchived: _showArchived,
          onTypeChanged: (type) => setState(() => _selectedType = type),
          onPinnedToggled: (value) => setState(() => _showPinned = value),
          onArchivedToggled: (value) => setState(() => _showArchived = value),
        ),
        Gap.h16,
        if (repo == null)
          EmptyStateCard(
            icon: Icons.cloud_off,
            title: 'Notes are unavailable',
            description:
                'Connect Supabase or enable Demo Mode to view notes here.',
            ctaLabel: 'Go to Settings',
            onCtaPressed: () => context.go('/settings'),
          )
        else
          asyncNotes.when(
            data: (notes) {
              // Apply filters to search results if needed
              final filtered = _searchQuery.trim().isNotEmpty
                  ? notes.where((note) {
                      if (_selectedType != null && note.type != _selectedType) {
                        return false;
                      }
                      if (_showPinned && !note.pinned) {
                        return false;
                      }
                      if (_showArchived && !note.archived) {
                        return false;
                      }
                      return true;
                    }).toList()
                  : notes;

              if (filtered.isEmpty) {
                return EmptyStateCard(
                  icon: _searchQuery.trim().isNotEmpty
                      ? Icons.search_off
                      : _selectedType != null
                          ? Icons.note_outlined
                          : Icons.inbox_outlined,
                  title: _searchQuery.trim().isNotEmpty
                      ? 'No results'
                      : _selectedType != null
                          ? 'No ${_selectedType!.name} notes'
                          : 'No notes yet',
                  description: _searchQuery.trim().isNotEmpty
                      ? 'Try a different search query.'
                      : 'Create your first note to get started.',
                  ctaLabel: _searchQuery.trim().isNotEmpty
                      ? null
                      : 'Create Note',
                  onCtaPressed: _searchQuery.trim().isNotEmpty
                      ? null
                      : _createNote,
                );
              }

              return Column(
                children: [
                  for (final note in filtered) ...[
                    NoteCard(
                      note: note,
                      onTap: () => context.go('/settings/notes/${note.id}'),
                      onPin: () => _handlePin(note),
                      onArchive: () => _handleArchive(note),
                    ),
                    Gap.h12,
                  ],
                ],
              );
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (error, stack) => EmptyStateCard(
              icon: Icons.error_outline,
              title: 'Failed to load notes',
              description: error.toString(),
              ctaLabel: 'Retry',
              onCtaPressed: _refresh,
            ),
          ),
      ],
    );
  }
}
